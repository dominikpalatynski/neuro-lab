# Neuro-Lab CLI Design Specification v2.0

## Overview

This document outlines the redesigned architecture for the neuro-lab CLI - a kubectl-inspired tool for preparing test stations. The key innovation is separating **human-editable YAML manifests** (declarative configuration) from **machine-readable JSON runtime state** (fetched from API for device consumption).

### Design Philosophy

The CLI is designed for **preparing test stations**, not running tests directly. It follows the kubectl model where:
- Humans write YAML manifests to define desired state
- CLI applies manifests to API (`neurolab apply -f`)
- Devices fetch JSON configuration from API for execution
- Context management focuses on device selection only

### Architecture Analogy

| Kubernetes | Neuro-Lab | Purpose |
|-----------|-----------|---------|
| YAML manifests | YAML manifests | Human-editable resource definitions |
| `kubectl apply -f` | `neurolab apply -f` | Create/update resources from YAML |
| `kubectl get -o json` | `neurolab get -o json` | Fetch runtime state as JSON |
| kubeconfig (cluster selection) | config (device selection) | Local CLI state |
| etcd/API server | Neuro-Lab API | Source of truth for runtime state |

---

## 1. File Separation Strategy

### YAML Manifests (Human-Editable, Version-Controlled)

**Purpose**: Declarative resource definitions
**Location**: `manifests/` directory
**Who writes**: Humans (engineers, scientists)
**Who reads**: CLI (to create/update resources)

**What goes here**:
- Device definitions
- Test session templates
- Scenario templates
- Condition definitions

**Why YAML**:
- Human-readable and writable
- Comments for documentation
- Version control friendly
- Industry standard (K8s, Docker Compose)

### JSON Runtime State (Machine-Readable, API-Generated)

**Purpose**: Runtime configuration for device consumption
**Location**: `runtime/` directory (gitignored)
**Who writes**: API (auto-generated)
**Who reads**: Devices (for test execution)

**What goes here**:
- Test session configuration with IDs
- Scenario definitions with database IDs
- Condition values with database IDs
- Execution state

**Why JSON**:
- Machine-readable
- Fast parsing
- Includes database IDs
- Not manually edited

### Context File (Local CLI State)

**Purpose**: CLI configuration and device selection
**Location**: `~/.neurolab/config` (YAML)
**Who writes**: CLI commands
**Who reads**: CLI

**What goes here**:
- Current device selection
- Device registry (local cache)
- CLI preferences
- **NOT test sessions** (they're ephemeral)

---

## 2. Simplified Context Management

### Context File Structure (`~/.neurolab/config`)

```yaml
# Simplified device registry (generated by 'neurolab init')
devices:
  - device:
      name: thermal-chamber-001
      device_id: 1

  - device:
      name: thermal-chamber-002
      device_id: 2
```

**Note**: The initial implementation uses a simplified config structure containing only the device registry. Future versions may include additional fields like `currentDevice`, `previousDevice`, `apiServer`, and CLI preferences as outlined in the full design specification.

### Why Simpler Than Original Design?

**Original design** (rejected):
- Context = Device + Test Session
- Test sessions cached in context file
- Complex context switching

**New design** (approved):
- Context = Device only
- Test sessions are ephemeral (created from templates)
- Sessions created fresh each time via `neurolab apply -f`
- Simpler, more like kubectl's cluster selection

---

## 3. YAML Manifest Structure

### Device Manifest

**File**: `manifests/devices/thermal-chamber-001.yaml`

```yaml
apiVersion: neurolab.io/v1
kind: Device
metadata:
  name: thermal-chamber-001
  labels:
    location: lab-1
    type: thermal
spec:
  description: "Environmental test chamber for thermal testing"
  apiServer: "http://localhost:3002"
  capabilities:
    - temperature-control
    - humidity-control
```

### Test Session Template

**File**: `manifests/templates/thermal-stress-test.yaml`

```yaml
apiVersion: neurolab.io/v1
kind: TestSessionTemplate
metadata:
  name: thermal-stress-test
  labels:
    category: environmental
    priority: high
spec:
  description: "Standard thermal stress test protocol"

  # Define conditions and their possible values
  conditions:
    - name: Temperature
      values:
        - "20C"
        - "25C"
        - "30C"
        - "35C"
        - "40C"

    - name: Humidity
      values:
        - "30%"
        - "50%"
        - "70%"
        - "90%"

  # Define scenarios (combinations of condition values)
  scenarios:
    - name: Baseline
      conditions:
        Temperature: "25C"
        Humidity: "50%"

    - name: Cold-Dry
      conditions:
        Temperature: "20C"
        Humidity: "30%"

    - name: Hot-Humid
      conditions:
        Temperature: "40C"
        Humidity: "90%"

    - name: Extreme-Stress
      conditions:
        Temperature: "40C"
        Humidity: "90%"
```

### Standalone Scenario Manifest

**File**: `manifests/scenarios/quick-baseline.yaml`

```yaml
apiVersion: neurolab.io/v1
kind: Scenario
metadata:
  name: quick-baseline
  labels:
    priority: low
spec:
  description: "Quick baseline test at room conditions"
  conditions:
    - name: Temperature
      value: "25C"
    - name: Humidity
      value: "50%"
```

### Multi-Resource Manifest (List)

**File**: `manifests/full-test-suite.yaml`

```yaml
apiVersion: neurolab.io/v1
kind: List
items:
  - apiVersion: neurolab.io/v1
    kind: Device
    metadata:
      name: chamber-001
    spec:
      apiServer: "http://localhost:3002"

  - apiVersion: neurolab.io/v1
    kind: TestSessionTemplate
    metadata:
      name: quick-environmental-test
    spec:
      conditions:
        - name: Temperature
          values: ["20C", "25C", "30C"]
      scenarios:
        - name: Cold
          conditions:
            Temperature: "20C"
        - name: Room
          conditions:
            Temperature: "25C"
```

---

## 4. JSON Runtime State Structure

### Test Session Configuration (API Response)

**File**: `runtime/sessions/session-42.json` (auto-generated)

```json
{
  "apiVersion": "neurolab.io/v1",
  "kind": "TestSession",
  "metadata": {
    "id": 42,
    "name": "thermal-stress-test-20251110-103045",
    "created": "2025-11-10T10:30:45Z",
    "deviceId": 1
  },
  "spec": {
    "conditions": [
      {
        "id": 1,
        "name": "Temperature",
        "values": [
          {"id": 101, "value": "20C"},
          {"id": 102, "value": "25C"},
          {"id": 103, "value": "30C"},
          {"id": 104, "value": "35C"},
          {"id": 105, "value": "40C"}
        ]
      },
      {
        "id": 2,
        "name": "Humidity",
        "values": [
          {"id": 201, "value": "30%"},
          {"id": 202, "value": "50%"},
          {"id": 203, "value": "70%"},
          {"id": 204, "value": "90%"}
        ]
      }
    ],
    "scenarios": [
      {
        "id": 301,
        "name": "Baseline",
        "conditionValues": [
          {"conditionId": 1, "valueId": 102, "value": "25C"},
          {"conditionId": 2, "valueId": 202, "value": "50%"}
        ]
      },
      {
        "id": 302,
        "name": "Cold-Dry",
        "conditionValues": [
          {"conditionId": 1, "valueId": 101, "value": "20C"},
          {"conditionId": 2, "valueId": 201, "value": "30%"}
        ]
      },
      {
        "id": 303,
        "name": "Hot-Humid",
        "conditionValues": [
          {"conditionId": 1, "valueId": 105, "value": "40C"},
          {"conditionId": 2, "valueId": 204, "value": "90%"}
        ]
      }
    ]
  },
  "status": {
    "phase": "Ready",
    "activeScenario": null,
    "completedScenarios": [],
    "startTime": null
  }
}
```

### Device Runtime Configuration (Simplified for Device)

**File**: `runtime/configs/chamber-001-session-42.json`

```json
{
  "sessionId": 42,
  "deviceId": 1,
  "deviceName": "thermal-chamber-001",
  "scenarios": [
    {
      "id": 301,
      "name": "Baseline",
      "conditions": {
        "Temperature": {"id": 102, "value": "25C"},
        "Humidity": {"id": 202, "value": "50%"}
      }
    },
    {
      "id": 302,
      "name": "Cold-Dry",
      "conditions": {
        "Temperature": {"id": 101, "value": "20C"},
        "Humidity": {"id": 201, "value": "30%"}
      }
    },
    {
      "id": 303,
      "name": "Hot-Humid",
      "conditions": {
        "Temperature": {"id": 105, "value": "40C"},
        "Humidity": {"id": 204, "value": "90%"}
      }
    }
  ]
}
```

---

## 5. Command Structure

### Core Commands (kubectl-inspired)

| Command | Purpose | Example |
|---------|---------|---------|
| `neurolab init` | Initialize CLI config | `neurolab init` |
| `neurolab apply -f FILE` | Create/update from YAML | `neurolab apply -f device.yaml` |
| `neurolab get RESOURCE` | List resources | `neurolab get devices` |
| `neurolab get RESOURCE NAME` | Get specific resource | `neurolab get session test-1` |
| `neurolab describe RESOURCE NAME` | Detailed resource info | `neurolab describe device chamber-001` |
| `neurolab delete RESOURCE NAME` | Delete resource | `neurolab delete session test-1` |
| `neurolab use device NAME` | Switch device context | `neurolab use device chamber-001` |
| `neurolab use device -` | Switch to previous device | `neurolab use device -` |

### Resource Types

- `device` / `devices`
- `session` / `sessions` (or `testsession`)
- `scenario` / `scenarios`
- `condition` / `conditions`

### Output Formats

All `get` commands support:
- `-o table` (default): Human-readable table
- `-o json`: Machine-readable JSON (for devices)
- `-o yaml`: YAML format (can be re-applied)

---

## 6. Complete Workflow

### Station Preparation Workflow

```bash
# Step 1: Initialize CLI
neurolab init

# Output:
# Created config file at ~/.neurolab/config
# Ready to apply manifests with 'neurolab apply -f'

# Step 2: Apply device configuration from YAML
neurolab apply -f manifests/devices/chamber-001.yaml

# Output:
# Device "thermal-chamber-001" created (ID: 1)

# Step 3: Select device as current context
neurolab use device thermal-chamber-001

# Output:
# Switched to device "thermal-chamber-001"

# Step 4: Apply test session template (creates ephemeral session)
neurolab apply -f manifests/templates/thermal-stress.yaml

# Output:
# TestSession "thermal-stress-test-20251110-103045" created (ID: 42)
# Created 2 conditions with 9 total values
# Created 4 scenarios
# Session ready for device consumption

# Step 5: Get runtime configuration as JSON (for device)
neurolab get session thermal-stress-test-20251110-103045 -o json > /tmp/session-config.json

# Device reads this JSON file and executes scenarios
# ...

# Step 6: Check session status
neurolab get session thermal-stress-test-20251110-103045

# Output (table format):
# NAME                                     ID   DEVICE                  STATUS   SCENARIOS
# thermal-stress-test-20251110-103045      42   thermal-chamber-001     Ready    4

# Step 7: Clean up when done
neurolab delete session thermal-stress-test-20251110-103045

# Output:
# TestSession "thermal-stress-test-20251110-103045" deleted
```

### Day-to-Day Usage

```bash
# Check current device
neurolab use device

# Output:
# Current device: thermal-chamber-001

# Switch device
neurolab use device thermal-chamber-002

# Switch back quickly
neurolab use device -

# List all devices
neurolab get devices

# Output (table):
# NAME                    ID   API-SERVER                  STATUS
# thermal-chamber-001     1    http://localhost:3002       Ready
# thermal-chamber-002     2    http://localhost:3003       Ready

# Apply multiple resources from directory
neurolab apply -f manifests/devices/

# Output:
# Device "chamber-001" created
# Device "chamber-002" created
# Device "chamber-003" updated

# Create session and get JSON in one flow
neurolab apply -f templates/quick-test.yaml && \
  neurolab get session quick-test-$(date +%Y%m%d-%H%M%S) -o json > config.json
```

---

## 7. Directory Structure

```
neuro-lab/
├── manifests/                          # YAML (version-controlled)
│   ├── devices/
│   │   ├── chamber-001.yaml
│   │   ├── chamber-002.yaml
│   │   └── chamber-003.yaml
│   │
│   ├── templates/                      # Test session templates
│   │   ├── thermal-stress.yaml
│   │   ├── humidity-test.yaml
│   │   ├── baseline.yaml
│   │   └── full-environmental-suite.yaml
│   │
│   └── scenarios/                      # Standalone scenarios
│       ├── quick-baseline.yaml
│       └── extreme-conditions.yaml
│
├── runtime/                            # JSON (gitignored)
│   ├── sessions/
│   │   ├── session-42.json
│   │   └── session-43.json
│   │
│   └── configs/                        # Device runtime configs
│       ├── chamber-001-session-42.json
│       └── chamber-002-session-43.json
│
├── .gitignore                          # Ignore runtime/
│
├── ~/.neurolab/
│   └── config                          # CLI context (device selection)
│
└── apps/cli/
    ├── cmd/
    │   ├── root.go
    │   ├── init.go
    │   ├── apply.go                    # neurolab apply -f
    │   ├── get.go                      # neurolab get [resource]
    │   ├── describe.go                 # neurolab describe [resource]
    │   ├── delete.go                   # neurolab delete [resource]
    │   └── use.go                      # neurolab use device
    │
    └── pkg/
        ├── manifest/                   # YAML parsing
        │   ├── parser.go
        │   ├── types.go
        │   └── validator.go
        │
        ├── config/                     # Context management
        │   ├── config.go
        │   └── types.go
        │
        └── client/                     # API client
            ├── client.go
            └── resources.go
```

---

## 8. Go Package Structure

### File: `apps/cli/pkg/manifest/types.go`

```go
package manifest

// Manifest represents any YAML manifest
type Manifest struct {
    APIVersion string      `yaml:"apiVersion"`
    Kind       string      `yaml:"kind"`
    Metadata   Metadata    `yaml:"metadata"`
    Spec       interface{} `yaml:"spec"` // Different per Kind
    Items      []Manifest  `yaml:"items,omitempty"` // For Kind: List
}

type Metadata struct {
    Name   string            `yaml:"name"`
    Labels map[string]string `yaml:"labels,omitempty"`
}

// DeviceSpec for Kind: Device
type DeviceSpec struct {
    Description  string   `yaml:"description,omitempty"`
    APIServer    string   `yaml:"apiServer"`
    Capabilities []string `yaml:"capabilities,omitempty"`
}

// TestSessionTemplateSpec for Kind: TestSessionTemplate
type TestSessionTemplateSpec struct {
    Description string              `yaml:"description,omitempty"`
    Conditions  []ConditionTemplate `yaml:"conditions"`
    Scenarios   []ScenarioTemplate  `yaml:"scenarios,omitempty"`
}

type ConditionTemplate struct {
    Name   string   `yaml:"name"`
    Values []string `yaml:"values"`
}

type ScenarioTemplate struct {
    Name        string            `yaml:"name"`
    Description string            `yaml:"description,omitempty"`
    Conditions  map[string]string `yaml:"conditions"` // ConditionName -> Value
}

// ScenarioSpec for Kind: Scenario (standalone)
type ScenarioSpec struct {
    Description string              `yaml:"description,omitempty"`
    Conditions  []ConditionAssignment `yaml:"conditions"`
}

type ConditionAssignment struct {
    Name  string `yaml:"name"`
    Value string `yaml:"value"`
}
```

### File: `apps/cli/pkg/manifest/parser.go`

```go
package manifest

import (
    "fmt"
    "os"
    "gopkg.in/yaml.v3"
)

// ParseManifest parses a YAML manifest file
func ParseManifest(filename string) (*Manifest, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        return nil, fmt.Errorf("failed to read file: %w", err)
    }

    var manifest Manifest
    if err := yaml.Unmarshal(data, &manifest); err != nil {
        return nil, fmt.Errorf("failed to parse YAML: %w", err)
    }

    return &manifest, nil
}

// Validate checks if manifest is valid
func (m *Manifest) Validate() error {
    if m.APIVersion == "" {
        return fmt.Errorf("apiVersion is required")
    }
    if m.Kind == "" {
        return fmt.Errorf("kind is required")
    }
    if m.Kind != "List" && m.Metadata.Name == "" {
        return fmt.Errorf("metadata.name is required")
    }

    // Kind-specific validation
    switch m.Kind {
    case "Device":
        return m.validateDeviceSpec()
    case "TestSessionTemplate":
        return m.validateTestSessionSpec()
    case "Scenario":
        return m.validateScenarioSpec()
    case "List":
        return m.validateList()
    default:
        return fmt.Errorf("unknown kind: %s", m.Kind)
    }
}

func (m *Manifest) validateDeviceSpec() error {
    spec, ok := m.Spec.(DeviceSpec)
    if !ok {
        return fmt.Errorf("invalid spec for Device")
    }
    if spec.APIServer == "" {
        return fmt.Errorf("spec.apiServer is required for Device")
    }
    return nil
}

// ... other validation methods
```

### File: `apps/cli/pkg/config/types.go` (Simplified)

```go
package config

// Config represents ~/.neurolab/config
type Config struct {
    APIVersion     string        `yaml:"apiVersion"`
    Kind           string        `yaml:"kind"`
    CurrentDevice  string        `yaml:"currentDevice,omitempty"`
    PreviousDevice string        `yaml:"previousDevice,omitempty"`
    Devices        []DeviceEntry `yaml:"devices"`
    Preferences    Preferences   `yaml:"preferences"`
}

type DeviceEntry struct {
    Name      string `yaml:"name"`
    DeviceID  uint   `yaml:"deviceId"`
    APIServer string `yaml:"apiServer"`
    LastSync  string `yaml:"lastSync,omitempty"`
}

type Preferences struct {
    OutputFormat string `yaml:"outputFormat"` // table, json, yaml
    Color        bool   `yaml:"color"`
    Editor       string `yaml:"editor"`
}
```

### File: `apps/cli/pkg/config/config.go`

```go
package config

import (
    "fmt"
    "os"
    "path/filepath"
    "gopkg.in/yaml.v3"
)

const (
    DefaultConfigDir  = ".neurolab"
    DefaultConfigFile = "config"
)

func GetConfigPath() (string, error) {
    home, err := os.UserHomeDir()
    if err != nil {
        return "", fmt.Errorf("failed to get home directory: %w", err)
    }
    return filepath.Join(home, DefaultConfigDir, DefaultConfigFile), nil
}

func LoadConfig() (*Config, error) {
    configPath, err := GetConfigPath()
    if err != nil {
        return nil, err
    }

    data, err := os.ReadFile(configPath)
    if err != nil {
        if os.IsNotExist(err) {
            return DefaultConfig(), nil
        }
        return nil, fmt.Errorf("failed to read config: %w", err)
    }

    var config Config
    if err := yaml.Unmarshal(data, &config); err != nil {
        return nil, fmt.Errorf("failed to parse config: %w", err)
    }

    return &config, nil
}

func SaveConfig(config *Config) error {
    home, err := os.UserHomeDir()
    if err != nil {
        return err
    }

    configDir := filepath.Join(home, DefaultConfigDir)
    if err := os.MkdirAll(configDir, 0755); err != nil {
        return err
    }

    configPath := filepath.Join(configDir, DefaultConfigFile)
    data, err := yaml.Marshal(config)
    if err != nil {
        return fmt.Errorf("failed to marshal config: %w", err)
    }

    return os.WriteFile(configPath, data, 0644)
}

func DefaultConfig() *Config {
    return &Config{
        APIVersion: "v1",
        Kind:       "Config",
        Devices:    []DeviceEntry{},
        Preferences: Preferences{
            OutputFormat: "table",
            Color:        true,
            Editor:       "vim",
        },
    }
}

// UseDevice switches to a device
func (c *Config) UseDevice(name string) error {
    // Verify device exists
    found := false
    for _, dev := range c.Devices {
        if dev.Name == name {
            found = true
            break
        }
    }

    if !found {
        return fmt.Errorf("device %q not found", name)
    }

    // Track previous device
    if c.CurrentDevice != "" {
        c.PreviousDevice = c.CurrentDevice
    }

    c.CurrentDevice = name
    return nil
}

// UsePreviousDevice switches back
func (c *Config) UsePreviousDevice() error {
    if c.PreviousDevice == "" {
        return fmt.Errorf("no previous device")
    }

    temp := c.CurrentDevice
    c.CurrentDevice = c.PreviousDevice
    c.PreviousDevice = temp

    return nil
}

// GetDevice returns device entry
func (c *Config) GetDevice(name string) (*DeviceEntry, error) {
    for _, dev := range c.Devices {
        if dev.Name == name {
            return &dev, nil
        }
    }
    return nil, fmt.Errorf("device %q not found", name)
}

// AddDevice adds or updates a device
func (c *Config) AddDevice(entry DeviceEntry) {
    for i, dev := range c.Devices {
        if dev.Name == entry.Name {
            c.Devices[i] = entry
            return
        }
    }
    c.Devices = append(c.Devices, entry)
}
```

---

## 9. Implementation Phases

### Phase 1: Core Infrastructure (Week 1)

**Goal**: Manifest parsing and simplified config management

**Tasks**:
1. Create `pkg/manifest/types.go` with manifest structs
2. Create `pkg/manifest/parser.go` with YAML parsing
3. Create `pkg/manifest/validator.go` with validation logic
4. Create `pkg/config/types.go` (simplified, devices only)
5. Create `pkg/config/config.go` with device switching
6. Add `neurolab init` command
7. Add `neurolab use device` command

**Files Created**:
- `apps/cli/pkg/manifest/types.go`
- `apps/cli/pkg/manifest/parser.go`
- `apps/cli/pkg/manifest/validator.go`
- `apps/cli/pkg/config/types.go`
- `apps/cli/pkg/config/config.go`
- `apps/cli/cmd/init.go` (updated)
- `apps/cli/cmd/use.go` (new)

**Estimated Effort**: 6-8 hours

---

### Phase 2: Apply Command (Week 2)

**Goal**: Implement `neurolab apply -f` for all resource types

**Tasks**:
1. Create `cmd/apply.go` with apply logic
2. Implement device creation from YAML
3. Implement test session creation from template YAML
4. Implement scenario creation from YAML
5. Add support for multi-resource manifests (Kind: List)
6. Create example YAML manifests

**Files Created**:
- `apps/cli/cmd/apply.go`
- `manifests/devices/` (examples)
- `manifests/templates/` (examples)
- `manifests/scenarios/` (examples)

**Estimated Effort**: 6-8 hours

---

### Phase 3: Get/Describe Commands (Week 3)

**Goal**: Retrieve and display resources

**Tasks**:
1. Create `cmd/get.go` with get logic
2. Implement `get devices`, `get sessions`, `get scenarios`
3. Add table output format (default)
4. Add JSON output format (`-o json`)
5. Add YAML output format (`-o yaml`)
6. Create `cmd/describe.go` for detailed resource info
7. Add tablewriter for formatted output

**Files Created**:
- `apps/cli/cmd/get.go`
- `apps/cli/cmd/describe.go`
- `apps/cli/pkg/output/` (formatting package)

**Estimated Effort**: 5-7 hours

---

### Phase 4: Delete & Polish (Week 4)

**Goal**: Complete CRUD operations and UX

**Tasks**:
1. Create `cmd/delete.go` for resource deletion
2. Add confirmation prompts for destructive operations
3. Improve error messages throughout
4. Add colorized output (green checkmarks, red errors)
5. Add command examples to help text
6. Create comprehensive documentation
7. Add bash/zsh completion scripts

**Files Created**:
- `apps/cli/cmd/delete.go`
- `docs/` (usage documentation)
- `completions/` (shell completion)

**Estimated Effort**: 4-6 hours

---

### Total Estimated Effort: 21-29 hours (3-4 weeks)

---

## 10. Dependencies

### Add to `apps/cli/go.mod`

```go
require (
    github.com/spf13/cobra v1.10.1        // Already exists
    gopkg.in/yaml.v3 v3.0.1               // YAML parsing
    github.com/olekukonko/tablewriter v0.0.5  // Table output
    github.com/fatih/color v1.16.0        // Colored output
)
```

### Install

```bash
cd apps/cli
go get gopkg.in/yaml.v3
go get github.com/olekukonko/tablewriter
go get github.com/fatih/color
```

---

## 11. Example Manifests

### Minimal Device

```yaml
apiVersion: neurolab.io/v1
kind: Device
metadata:
  name: my-chamber
spec:
  apiServer: http://localhost:3002
```

### Complete Test Session Template

```yaml
apiVersion: neurolab.io/v1
kind: TestSessionTemplate
metadata:
  name: comprehensive-environmental-test
  labels:
    category: environmental
    duration: long
    priority: high
spec:
  description: "Complete environmental stress test covering temperature, humidity, and pressure ranges"

  conditions:
    - name: Temperature
      values: ["0C", "10C", "20C", "25C", "30C", "40C", "50C"]

    - name: Humidity
      values: ["10%", "30%", "50%", "70%", "90%"]

    - name: Pressure
      values: ["0.5atm", "1.0atm", "1.5atm", "2.0atm"]

  scenarios:
    - name: Baseline
      conditions:
        Temperature: "25C"
        Humidity: "50%"
        Pressure: "1.0atm"

    - name: Cold-Low-Pressure
      conditions:
        Temperature: "0C"
        Humidity: "30%"
        Pressure: "0.5atm"

    - name: Hot-High-Humidity
      conditions:
        Temperature: "50C"
        Humidity: "90%"
        Pressure: "1.0atm"

    - name: Extreme
      conditions:
        Temperature: "50C"
        Humidity: "90%"
        Pressure: "2.0atm"
```

---

## 12. Key Design Decisions

### 1. Why Test Sessions Are Ephemeral

**Decision**: Test sessions are created fresh from templates each time, not cached in context file

**Rationale**:
- Sessions have runtime state (active scenario, completion status)
- Sessions are created for specific test runs, then deleted
- Caching them adds complexity without benefit
- Simpler to fetch fresh from API when needed

**Alternative considered**: Cache sessions in context file
**Rejected because**: Added complexity, sessions change frequently, not aligned with "preparing stations" use case

### 2. Why Separate YAML and JSON

**Decision**: YAML for humans, JSON for machines

**Rationale**:
- YAML is readable, commentable, version-controllable
- JSON includes database IDs needed by devices
- Clear separation of concerns
- Devices shouldn't read YAML (parsing overhead, no IDs)

**Alternative considered**: Use YAML everywhere
**Rejected because**: Devices need IDs, YAML parsing in devices is unnecessary

### 3. Why Context Is Device-Only

**Decision**: Context tracks current device, not test session

**Rationale**:
- Aligns with "preparing stations" use case
- Sessions are ephemeral (created per test run)
- Simpler mental model
- Like kubectl's cluster selection

**Alternative considered**: Context = Device + Session (original design)
**Rejected because**: Sessions are ephemeral, added complexity

### 4. Why kubectl-style Commands

**Decision**: Use `apply`, `get`, `describe`, `delete` like kubectl

**Rationale**:
- Familiar to DevOps/SRE users
- Industry standard pattern
- Declarative workflow (YAML → apply)
- Well-understood semantics

**Alternative considered**: Custom command structure
**Rejected because**: Reinventing the wheel, less intuitive

---

## 13. Migration from Original Design

### Changes from v1.0 Design

| Aspect | Original (v1.0) | New (v2.0) |
|--------|-----------------|------------|
| Context | Device + Test Session | Device only |
| Session Storage | Cached in context file | Ephemeral (from API) |
| Configuration | YAML only | YAML (human) + JSON (machine) |
| Session Creation | Imperative commands | Declarative manifests |
| Commands | `create`, `ctx`, `sync` | `apply`, `get`, `use device` |
| Test Session Lifecycle | Persistent | Ephemeral (template-based) |

### Migration Path

**For new users**: Start with v2.0 design (this document)

**For existing users** (if any were using v1.0):
1. Export existing devices to YAML manifests
2. Convert session configurations to templates
3. Update workflows to use `apply` instead of `create`
4. Use `use device` instead of `ctx`

---

## 14. Naming Conventions

### YAML Manifests

- Lowercase with hyphens: `thermal-chamber-001.yaml`
- Descriptive names: `comprehensive-stress-test.yaml`, not `test1.yaml`
- Group related: `lab1-devices.yaml`

### Resource Names (metadata.name)

- Lowercase with hyphens
- Unique and descriptive: `thermal-chamber-001`
- Purpose-based: `baseline-thermal-test`

### JSON Runtime Files

- Auto-generated: `session-42.json`
- Include IDs: `chamber-001-session-42.json`
- Not human-edited

### Labels

- Key-value pairs for organization
- Examples:
  - `location: lab-1`
  - `type: thermal`
  - `priority: high`
  - `category: environmental`

---

## 15. Testing Strategy

### Unit Tests

**`apps/cli/pkg/manifest/parser_test.go`**:
- Parse valid YAML manifests
- Reject invalid YAML
- Validate required fields
- Handle multi-resource manifests

**`apps/cli/pkg/config/config_test.go`**:
- Load/save config
- Device switching
- Previous device tracking
- Error handling

### Integration Tests

**End-to-end workflows**:
1. `init` → `apply device` → `use device` → `apply template` → `get session`
2. Multi-device management
3. YAML validation and error reporting
4. JSON output for device consumption

### Manual Testing Checklist

- [ ] `neurolab init` creates config file
- [ ] `neurolab apply -f device.yaml` creates device
- [ ] `neurolab use device` switches devices
- [ ] `neurolab use device -` switches to previous
- [ ] `neurolab apply -f template.yaml` creates session
- [ ] `neurolab get session -o json` returns valid JSON
- [ ] `neurolab delete session` cleans up
- [ ] Error messages are helpful
- [ ] Table output is formatted correctly
- [ ] Colors work in terminal

---

## 16. Future Enhancements

### Phase 5: Advanced Features

- **Directory apply**: `neurolab apply -f manifests/`
- **Dry-run mode**: `neurolab apply -f device.yaml --dry-run`
- **Diff before apply**: Show what will change
- **Watch mode**: `neurolab get sessions --watch`
- **Session logs**: `neurolab logs session-42`

### Phase 6: Experiment Management

```bash
# Define multi-session experiment
neurolab apply -f experiments/long-duration-test.yaml

# Monitor experiment progress
neurolab experiment status long-duration-test

# Get experiment results
neurolab experiment results long-duration-test -o json
```

### Phase 7: Advanced Tooling

- **Auto-completion**: Bash/Zsh completion for resource names
- **Plugins**: Extend CLI with custom commands
- **Remote config**: Sync manifests from git repo
- **Interactive mode**: TUI for visual management (bubbletea)
- **Validation webhook**: Pre-apply manifest validation

---

## 17. Summary

This v2.0 design provides a clean, kubectl-inspired CLI for preparing test stations:

✅ **Clear separation**: YAML (human) vs JSON (machine)
✅ **Simplified context**: Device selection only
✅ **Declarative workflow**: Manifests → `apply` → runtime state
✅ **Familiar commands**: `apply`, `get`, `describe`, `delete`
✅ **Ephemeral sessions**: Created from templates, not cached
✅ **Version control**: YAML manifests in git
✅ **Device-ready**: JSON with IDs for execution

The architecture scales from simple single-device setups to complex multi-device test stations while maintaining clarity and ease of use.
